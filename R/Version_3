# Work in progress
# Author: Anthony T.O'Brien Villate MD/MPH
# Version 3.0

# 0. Load libraries ----
library("tidyr")
library("dplyr")
library("markovchain")
library("tdisplay", lib.loc="~/R/win-library/3.5")
library("survival", lib.loc="~/R/win-library/3.5")
library("survminer", lib.loc="~/R/win-library/3.5")
library("parallel")
library("stringr")
library("data.table")
library("runner")
library("DataCombine")
library("msm")

# note to self: need to set seeds
#----
# 1. Select cirrhosis cohort ----
#
# See code here----
  # Read data
  df<-read.csv("C:/Users/Me/Desktop/mimic_timecohort_20190304.csv")
  
  # Replace NA in flags with 0
  df<-df %>% 
    mutate(death_flag = replace_na(death_flag, 0),
           cv_flag = replace_na(cv_flag, 0),
           crrt_flag = replace_na(crrt_flag, 0),
           vasopres_flag = replace_na(vasopres_flag, 0),
           mechvent_flag = replace_na(mechvent_flag, 0),
           cmo_flag = replace_na(cmo_flag, 0))
  
  # Select icustays with more than 1 day stay, only first time admission,
  # >=18years and with a sofa score
  df<-df %>% 
    group_by(icustay_id) %>% 
    filter(length(icustay_id)>1 & 
             first_icu_stay %in% "True" & 
             admission_age>=18 &
             !is.na(sofa_last))
  
  # Import the cirrhosis dataframe. This contains the patients diagnosed with
  # cirrhosis. It will be used as a key to select only cirrhosis patients
  key<-read.csv("C:/Users/Me/Desktop/data-1546976302496.csv")
  
  # Prepare the key 
  key$charttime<-NULL
  key$day_start<-NULL
  key$cirrhosis_flag<-NULL
  
  # Using semi-join with the key we filter only the cirrhosis patients in the df 
  df<-semi_join(df, key)
  
  # Drop key for memory
  rm(key)
  
  # Turn variables into correct types
  df<-df %>% 
    mutate(death_flag= as.numeric(death_flag), states= as.numeric(states))
  
  # Find the quartiles of SOFA for first day of admission (day 0)
  sofa<-df %>% filter(icudayseq_asc == 0)
  quantile(sofa$sofa_last)
  q.sofa<-floor(quantile(sofa$sofa_last))
  
  # Results(floor):
  # 0%  25%  50%  75% 100% 
  # 0    4    7   10.5   22 
  # Q1: 0-4
  # Q2: 5-7
  # Q3: 8-10
  # Q4: 11-22
  
  # Assign cohort groups to sofa data frame
  
  sofa<-sofa %>% mutate(sofa_group= case_when(sofa_last %in% c(q.sofa[[1]]:q.sofa[[2]])~"Q1",
                                              sofa_last %in% c(q.sofa[[2]]+1:q.sofa[[3]])~"Q2",
                                              sofa_last %in% c(q.sofa[[3]]+1:q.sofa[[4]])~"Q3",
                                              sofa_last %in% c(q.sofa[[4]]+1:q.sofa[[5]])~"Q4"))
  
  sofa<- sofa %>% select(icustay_id, sofa_group)
  
  # Using semi-join with the sofa dataframe we add the sofa group to  df 
  df<-merge(df, sofa, by="icustay_id")
  
  # Remove sofa from memory
  rm(sofa)
  rm(q.sofa)




  
# 
#----
# 2. Redefine CMO  ----
#
# See code here----
  
  # CMO will be redefined as follows: 
  # state--lead_state_1_day_out--2_day_out--3_day_out--4_day_out--5_day_out--CMO
  #   1               0              4                                        1
  #   1               0              0           4                            1 
  #   1               0              0           0         4                  1 
  #   1               0              0           0         0          4       1
  # This is making the assumption that patients that transition from 
  # highly invasive care to non-invasive care and then died were on CMO 
  
  df<-df %>% 
    mutate(onedayout=lead(states, n=1L),
           twodayout=lead(states, n=2L),
           threedayout=lead(states, n=3L),
           fourdayout=lead(states, n=4L),
           fivedayout=lead(states, n=5L),
           sixdayout=lead(states, n=6L),
           sevendayout=lead(states, n=7L),
           eightdayout=lead(states, n=8L),
           ninedayout=lead(states, n=9L),
           tendayout=lead(states, n=10L))
  
  df<-df %>% 
    mutate(CMO_additional_flag=
             case_when((states==1)&(onedayout==0)&(twodayout==4)~1,
                       (states==1)&(onedayout==0)&(twodayout==0)&(threedayout==4)~1,
                       (states==1)&(onedayout==0)&(twodayout==0)&(threedayout==0)&(fourdayout==4)~1,
                       (states==1)&(onedayout==0)&(twodayout==0)&(threedayout==0)&(fourdayout==0)&(fivedayout==4)~1,
                       (states==1)&(onedayout==0)&(twodayout==0)&(threedayout==0)&(fourdayout==0)&(fivedayout==0)&(sixdayout==4)~1,
                       (states==1)&(onedayout==0)&(twodayout==0)&(threedayout==0)&(fourdayout==0)&(fivedayout==0)&(sixdayout==0)&(sevendayout==4)~1,
                       (states==1)&(onedayout==0)&(twodayout==0)&(threedayout==0)&(fourdayout==0)&(fivedayout==0)&(sixdayout==0)&(sevendayout==0)&(eightdayout==4)~1,
                       (states==1)&(onedayout==0)&(twodayout==0)&(threedayout==0)&(fourdayout==0)&(fivedayout==0)&(sixdayout==0)&(sevendayout==0)&(eightdayout==0)&(ninedayout==4)~1,
                       (states==1)&(onedayout==0)&(twodayout==0)&(threedayout==0)&(fourdayout==0)&(fivedayout==0)&(sixdayout==0)&(sevendayout==0)&(eightdayout==0)&(ninedayout==0)&(tendayout==4)~1))
  
  # Drop additional columns created to be organized
  df$onedayout<-NULL
  df$twodayout<-NULL
  df$threedayout<-NULL
  df$fourdayout<-NULL
  df$fivedayout<-NULL
  df$sixdayout<-NULL
  df$sevendayout<-NULL
  df$eightdayout<-NULL
  df$ninedayout<-NULL
  df$tendayout<-NULL
  
  # Add in the end state when it is dead (4) 
  df<-df %>% 
    mutate(A= ifelse(states==4, 4,CMO_additional_flag))
  
  # Filling in CMO cases according to above assumption on post-HIC days
  A <- c(df$A)
  index.1<-which(df$A %in% c(1)) # define location for 1s in A
  index.14<-which(df$A %in% c(1,4)) # define location for 1s and 4s in A
  loc.1<-which(index.14 %in% index.1) # location of 1s in  index.14
  loc.4<-loc.1+1 # location of 4s relative to 1s in index.14
  start.i<-((index.14[loc.1])+1) # starting index for replacing with 2
  end.i<-((index.14[loc.4])-1) # ending index for replacing with 2 in index
  fill.v<-sort(c(start.i, end.i))# sequence of indexes to fill-in with # 2
  fill.m<-matrix(fill.v,nrow = (length(fill.v)/2),ncol = 2, byrow=TRUE) # create matrix of 
  list.1<-apply(fill.m, MARGIN=1,FUN=function(x) seq(x[1],x[2])) # create a list with indexes to replace
  list.2<-unlist(list.1) # unlist list to use as the indexes for replacement
  df$A[list.2] <- 2 # replace indexed location with 2
  
  rm(index.1)
  rm(index.14)
  rm(loc.1)
  rm(loc.4)
  rm(start.i)
  rm(end.i)
  rm(fill.v)
  rm(fill.m)
  rm(list.2)
  rm(list.1)
  rm(A)
  
  # Update states & cmo flag with new CMO definition
  df<-df %>%mutate(states= ifelse(A %in% 2, 2, states),
                   cmo_flag=ifelse(A %in% 2, 1, cmo_flag))
  df$A<-NULL
  df$CMO_additional_flag<-NULL
  
  # ASSUMPTION 
  # this is a mismatch in logic can't go from 4->3
  df[2038,10] <-1 
  df[3663,10] <-1 
  # this is to match the previous correction 
  df[2038,6] <-0 
  df[3663,6] <-0 
#
#----
# 3. Select patients which entered into HIC without re-entry ----
#
# See code here----

  index.1<-which(df$states %in% c(1)) # index all the rows with 1
  df<- df %>% mutate(col1=streak_run(states, k=1000)) # create a streak
  df.collect<-df %>% .[c(index.1),] # collect all the rows with 1`
  key<-df.collect %>% group_by(icustay_id) %>% count(col1) %>% filter(col1%in%1 & n!=1) # keep rentries into HIC  
  key<-key[,1] # save ids for re-entries into HIC
  df<-anti_join(df, key)# keep only those which do not re-enter HIC
  rm(df.collect)
  rm(key)
#
#  
#----
# Base case analysis ----  
#
#----
# 4. Function to extract population with X days of HIC----
#
# See code here----
    example.df<-df
    example.df<-example.df %>% select(icustay_id, icudayseq_asc, states, sofa_group)
    colnames(example.df)[1] <- 'id'  
    colnames(example.df)[2] <- 'day'  
    colnames(example.df)[4] <- 'sofa'  
    
    f1 <- function(data, n){
      ids <- data %>%
        mutate(stateslead = lead(states, default = last(states))) %>%
        group_by(grp = rleid(states == 1)) %>% 
        filter(n() == n, states == 1, stateslead != 1) %>%     
        group_by(id) %>%     
        filter(n() == 1) %>%
        pull(id)
      
      data %>%
        filter(id %in% ids) %>%
        group_by(id) %>% 
        filter(cumsum(states) > 0)}
#
# ACKNOWLEDGMENT ON CODE: 
# https://stackoverflow.com/questions/55432875/select-rows-of-ids-that-have-a-pattern-without-losing-the-other-rows/55434003?noredirect=1#comment97588830_55434003
#
#----
# 5. Transition matrix for 1 day if HIC----
# 
# 
df1.msm<-f1(example.df, 1)
# transition table
df1.tt<-(statetable.msm(states, id, data=df1.msm))
# transition matrix
df1.tm<-as.matrix.data.frame(df1.tt)
df1.tm<-rbind(df1.tm, c(0,0,0,1,0))
df1.tm<-rbind(df1.tm, c(0,0,0,0,1))
df1.ptm<-df1.tm/rowSums(df1.tm)    
#
# ASSUMPTION:
# Due to the limited number of individuals that have only 2 days HIC, then only
# 3 days of HIC, then only 4, up to only 30 days etc. We used a closed form 
# solution by exponentiating the 1 day HIC transition matrix
# Cl
# See code here----
#----
# 6. Markov object for 1 day HIC----
# See code here ----
mo1.msm<-new("markovchain",transitionMatrix=(df1.ptm), name="MarkovChain Q1")
#----
# 7. For-loop to generate closed form soluation for markov objects days 2-30 ----
# See code here ----
iter<-30
mobject.loop<-lapply(seq(iter), function(k) mo1.msm^k)
#Acknowledgement:
# https://stackoverflow.com/questions/32052315/r-markov-chain-output-iteration
#
#----
# 8. For-loop markov chain for closed form solution matrices 1 to 30 days HIC ----
# See code here ----
markov.object<-30 # this is the markov object transition matrix
patients<-10 # this is for simulated patients, e.g. 10 means 10 simulated patients for 1-30 days
N<-30 # this is the number of days 
rmchain.loop<-lapply(seq(patients), function(x) lapply(seq(days), function(k) rmarkovchain(n = N, 
                                           object = mo.loops[[k]],
                                           t0 = "2",
                                           include.t0 = TRUE,
                                           parallel = TRUE,
                                           num.cores=detectCores()-1)))
#----
# 9. Convert list of list into a matrix ----
# See code here ----
matrix.rmchains<-matrix(unlist(rmchain.loop),ncol=31, byrow=TRUE)
#----
# 10. Convert matrix into matrix list for each simulation closed loop solutionn 1-30 ----
# See code here ----
iter2<-30
matrix.sim.list<-lapply(seq(iter2), function(k) t(matrix(df.sim.list[[k]], nrow=nrow(df.sim.list[[k]]), ncol=31, byrow=FALSE)))
matrix.sim.list.vertical<-lapply(seq(iter2), function(k) matrix(matrix.sim.list[[k]]))

